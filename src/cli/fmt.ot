import { loadManifest } from "../config/manifest.ot";

interface FmtOptions {
    check: boolean;
    verbose: boolean;
    files: string[];
}

function parseFmtArgs(args: string[]): FmtOptions {
    let options: FmtOptions = {
        check: false,
        verbose: false,
        files: []
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--check") {
            options.check = true;
        } else if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg[0] != "-") {
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

function runFmt(args: string[]): number {
    let options = parseFmtArgs(args);

    let files = options.files;
    if (files.length == 0) {
        files = discoverSourceFiles("./src");
    }

    if (files.length == 0) {
        console.log("No files to format");
        return 0;
    }

    let formatted = 0;
    let unchanged = 0;
    let errors = 0;

    let i = 0;
    while (i < files.length) {
        let file = files[i];
        let result = formatFile(file, options.check);

        if (result.error != "") {
            console.error("Error formatting " + file + ": " + result.error);
            errors = errors + 1;
        } else if (result.changed) {
            formatted = formatted + 1;
            if (options.verbose) {
                console.log("Formatted: " + file);
            }
        } else {
            unchanged = unchanged + 1;
            if (options.verbose) {
                console.log("Unchanged: " + file);
            }
        }

        i = i + 1;
    }

    if (options.check) {
        if (formatted > 0) {
            console.log(formatted + " file(s) would be reformatted");
            return 1;
        }
        console.log("All files formatted correctly");
        return 0;
    }

    if (formatted > 0) {
        console.log("Formatted " + formatted + " file(s)");
    } else {
        console.log("All files already formatted");
    }

    return errors > 0 ? 1 : 0;
}

interface FormatResult {
    changed: boolean;
    error: string;
}

function formatFile(path: string, checkOnly: boolean): FormatResult {
    let content = readFile(path);
    if (content == null) {
        return { changed: false, error: "could not read file" };
    }

    let formatted = formatSource(content);

    if (formatted == content) {
        return { changed: false, error: "" };
    }

    if (!checkOnly) {
        let result = writeFile(path, formatted);
        if (!result.success) {
            return { changed: false, error: result.error };
        }
    }

    return { changed: true, error: "" };
}

function formatSource(source: string): string {
    let lines = source.split("\n");
    let result: string[] = [];

    let i = 0;
    while (i < lines.length) {
        let line = trimRight(lines[i]);
        result.push(line);
        i = i + 1;
    }

    let output = result.join("\n");
    if (output.length > 0 && output[output.length - 1] != "\n") {
        output = output + "\n";
    }

    return output;
}

function trimRight(s: string): string {
    let end = s.length;
    while (end > 0 && (s[end - 1] == " " || s[end - 1] == "\t")) {
        end = end - 1;
    }
    return s.substring(0, end);
}

function discoverSourceFiles(dir: string): string[] {
    let files: string[] = [];
    discoverSourceFilesRecursive(dir, files);
    return files;
}

function discoverSourceFilesRecursive(dir: string, files: string[]): void {
    if (!fs.existsSync(dir)) {
        return;
    }

    let entries = fs.readdirSync(dir);
    let i = 0;
    while (i < entries.length) {
        let entry = entries[i];
        let fullPath = dir + "/" + entry;

        let stats = fs.statSync(fullPath);
        if (stats && stats.isDirectory && stats.isDirectory()) {
            discoverSourceFilesRecursive(fullPath, files);
        } else if (entry.indexOf(".ot") == entry.length - 3) {
            files.push(fullPath);
        }

        i = i + 1;
    }
}

function readFile(path: string): string | null {
    try {
        return fs.readFileSync(path);
    } catch (e) {
        return null;
    }
}

interface WriteResult {
    success: boolean;
    error: string;
}

function writeFile(path: string, content: string): WriteResult {
    try {
        fs.writeFileSync(path, content);
        return { success: true, error: "" };
    } catch (e) {
        return { success: false, error: "Failed to write file" };
    }
}

export { runFmt, FmtOptions };
