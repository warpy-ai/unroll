// Dependency resolver - resolve package versions and build dependency graph

import { Manifest, Dependency } from "../config/manifest.ot";
import { LockedPackage } from "../config/lockfile.ot";
import { fetchPackageVersions, PackageVersion, VersionDependency } from "../registry/client.ot";
import { getRegistryConfig } from "../registry/config.ot";

interface ResolveResult {
    packages: LockedPackage[];
    error: string;
}

interface DependencyNode {
    name: string;
    version: string;
    dependencies: DependencyNode[];
}

// The implicit standard library dependency
const STD_DEPENDENCY: Dependency = {
    name: "@rolls/std",
    version: "0.1",
    optional: false,
    features: [],
    git: "",
    branch: "",
    path: ""
};

function resolveDependencies(manifest: Manifest, noStd: boolean = false): ResolveResult {
    let resolved: LockedPackage[] = [];
    let visited: string[] = [];

    // Inject @rolls/std implicitly unless disabled
    // This is the prelude that provides standard library functions automatically
    if (!manifest.noStd && !noStd) {
        let stdResult = resolveSingle(STD_DEPENDENCY, visited, resolved);
        if (stdResult.error != "") {
            return { packages: [], error: stdResult.error };
        }
    }

    // Resolve all direct dependencies
    for (let dep of manifest.dependencies) {
        let result = resolveSingle(dep, visited, resolved);
        if (result.error != "") {
            return { packages: [], error: result.error };
        }
    }

    // Resolve dev dependencies
    for (let dep of manifest.devDependencies) {
        let result = resolveSingle(dep, visited, resolved);
        if (result.error != "") {
            return { packages: [], error: result.error };
        }
    }

    // Sort for deterministic lockfile
    resolved = sortPackages(resolved);

    return { packages: resolved, error: "" };
}

interface SingleResult {
    error: string;
}

function resolveSingle(dep: Dependency, visited: string[], resolved: LockedPackage[]): SingleResult {
    // Check if already resolved
    if (isVisited(dep.name, visited)) {
        return { error: "" };
    }

    // Mark as visited
    visited.push(dep.name);

    // Fetch available versions
    let versions = fetchPackageVersions(dep.name);
    if (versions.error != "") {
        return { error: "Failed to fetch versions for " + dep.name + ": " + versions.error };
    }

    // Find best matching version
    let selected = selectVersion(dep.version, versions.versions);
    if (selected == null) {
        return { error: "No matching version found for " + dep.name + "@" + dep.version };
    }

    // Resolve transitive dependencies
    for (let depInfo of selected.dependencies) {
        // Skip optional dependencies for now
        if (depInfo.optional) {
            continue;
        }
        let transDep: Dependency = {
            name: depInfo.name,
            version: depInfo.req,  // API returns "req" not "version"
            optional: false,
            features: [],
            git: "",
            branch: "",
            path: ""
        };
        let result = resolveSingle(transDep, visited, resolved);
        if (result.error != "") {
            return result;
        }
    }

    // Add to resolved list
    let depNames: string[] = [];
    for (let depInfo of selected.dependencies) {
        if (!depInfo.optional) {
            depNames.push(depInfo.name + " " + depInfo.req);
        }
    }

    let config = getRegistryConfig();
    resolved.push({
        name: dep.name,
        version: selected.version,
        source: "registry+" + config.url,
        checksum: selected.checksum,
        dependencies: depNames
    });

    return { error: "" };
}

function isVisited(name: string, visited: string[]): boolean {
    for (let v of visited) {
        if (v == name) {
            return true;
        }
    }
    return false;
}

function selectVersion(requirement: string, versions: PackageVersion[]): PackageVersion | null {
    // Simple version matching
    // TODO: Implement full semver parsing and matching

    if (requirement == "*" || requirement == "") {
        // Return latest version
        if (versions.length > 0) {
            return versions[0];
        }
        return null;
    }

    // Exact match
    if (requirement[0] == "=") {
        let exact = requirement.substring(1);
        for (let ver of versions) {
            if (ver.version == exact) {
                return ver;
            }
        }
        return null;
    }

    // Caret range (default) - ^0.1.0 means >=0.1.0, <0.2.0
    for (let ver of versions) {
        if (matchesCaretRange(requirement, ver.version)) {
            return ver;
        }
    }

    return null;
}

function matchesCaretRange(requirement: string, version: string): boolean {
    // Parse requirement (e.g., "0.1" or "0.1.0")
    let reqParts = requirement.split(".");
    let verParts = version.split(".");

    // Must match major version
    if (reqParts.length > 0 && verParts.length > 0) {
        if (reqParts[0] != verParts[0]) {
            return false;
        }
    }

    // For 0.x versions, must also match minor
    if (reqParts[0] == "0" && reqParts.length > 1 && verParts.length > 1) {
        if (reqParts[1] != verParts[1]) {
            return false;
        }
    }

    return true;
}

function sortPackages(packages: LockedPackage[]): LockedPackage[] {
    // Simple bubble sort by name
    for (let i = 0; i < packages.length; i = i + 1) {
        for (let j = i + 1; j < packages.length; j = j + 1) {
            if (packages[j].name < packages[i].name) {
                let temp = packages[i];
                packages[i] = packages[j];
                packages[j] = temp;
            }
        }
    }
    return packages;
}

export { resolveDependencies, ResolveResult };
