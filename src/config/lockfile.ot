// Lockfile (unroll.lock) parsing and generation

interface Lockfile {
    version: number;
    packages: LockedPackage[];
}

interface LockedPackage {
    name: string;
    version: string;
    source: string;
    checksum: string;
    dependencies: string[];
}

function loadLockfile(path: string): Lockfile | null {
    let content = readFile(path);
    if (content == null) {
        return null;
    }

    return parseLockfile(content);
}

function writeLockfile(path: string, packages: LockedPackage[]): Result {
    let content = serializeLockfile(packages);
    return writeFile(path, content);
}

function parseLockfile(content: string): Lockfile {
    let lockfile: Lockfile = {
        version: 1,
        packages: []
    };

    let lines = content.split("\n");
    let currentPackage: LockedPackage | null = null;
    let inDependencies = false;

    for (let line of lines) {
        line = line.trim();

        // Skip empty lines and comments
        if (line == "" || line[0] == "#") {
            continue;
        }

        // Package section start
        if (line == "[[package]]") {
            if (currentPackage != null) {
                lockfile.packages.push(currentPackage);
            }
            currentPackage = {
                name: "",
                version: "",
                source: "",
                checksum: "",
                dependencies: []
            };
            inDependencies = false;
            continue;
        }

        // Key-value pair
        let eqIndex = line.indexOf("=");
        if (eqIndex > 0 && currentPackage != null) {
            let key = line.substring(0, eqIndex).trim();
            let value = line.substring(eqIndex + 1).trim();

            // Remove quotes
            if (value[0] == "\"" && value[value.length - 1] == "\"") {
                value = value.substring(1, value.length - 1);
            }

            if (key == "name") currentPackage.name = value;
            else if (key == "version") currentPackage.version = value;
            else if (key == "source") currentPackage.source = value;
            else if (key == "checksum") currentPackage.checksum = value;
            else if (key == "dependencies") {
                currentPackage.dependencies = parseArray(value);
            }
        }
    }

    // Add last package
    if (currentPackage != null) {
        lockfile.packages.push(currentPackage);
    }

    return lockfile;
}

function parseArray(value: string): string[] {
    let result: string[] = [];

    // Remove brackets
    if (value[0] == "[" && value[value.length - 1] == "]") {
        value = value.substring(1, value.length - 1);
    }

    // Split by comma
    let items = value.split(",");
    for (let item of items) {
        item = item.trim();
        // Remove quotes
        if (item[0] == "\"" && item[item.length - 1] == "\"") {
            item = item.substring(1, item.length - 1);
        }
        if (item != "") {
            result.push(item);
        }
    }

    return result;
}

function serializeLockfile(packages: LockedPackage[]): string {
    let output = "# This file is auto-generated by Unroll. Do not edit.\n";
    output = output + "# unroll.lock format version 1\n\n";

    for (let pkg of packages) {
        output = output + "[[package]]\n";
        output = output + "name = \"" + pkg.name + "\"\n";
        output = output + "version = \"" + pkg.version + "\"\n";
        output = output + "source = \"" + pkg.source + "\"\n";
        output = output + "checksum = \"" + pkg.checksum + "\"\n";

        if (pkg.dependencies.length > 0) {
            output = output + "dependencies = [\n";
            for (let j = 0; j < pkg.dependencies.length; j = j + 1) {
                output = output + "    \"" + pkg.dependencies[j] + "\"";
                if (j < pkg.dependencies.length - 1) {
                    output = output + ",";
                }
                output = output + "\n";
            }
            output = output + "]\n";
        } else {
            output = output + "dependencies = []\n";
        }

        output = output + "\n";
    }

    return output;
}

interface Result {
    success: boolean;
    error: string;
}

function readFile(path: string): string | null {
    try {
        return fs.readFileSync(path);
    } catch (e) {
        return null;
    }
}

function writeFile(path: string, content: string): Result {
    try {
        fs.writeFileSync(path, content);
        return { success: true, error: "" };
    } catch (e) {
        return { success: false, error: "Failed to write file: " + path };
    }
}

export {
    Lockfile,
    LockedPackage,
    loadLockfile,
    writeLockfile
};
