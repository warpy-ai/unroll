import { Manifest } from "../config/manifest.ot";
import { Lockfile } from "../config/lockfile.ot";

interface CompileOptions {
    profile: string;
    target: string;
    jobs: number;
    verbose: boolean;
}

interface CompileResult {
    success: boolean;
    error: string;
    objects: string[];
    warnings: CompileWarning[];
}

interface CompileWarning {
    file: string;
    line: number;
    message: string;
}

function compileSources(manifest: Manifest, lockfile: Lockfile | null, options: CompileOptions): CompileResult {
    let result: CompileResult = {
        success: false,
        error: "",
        objects: [],
        warnings: []
    };

    let sources = discoverSources("./src");
    if (sources.length == 0) {
        result.error = "No source files found";
        return result;
    }

    let outputDir = "./target/" + options.profile;
    createDirectory(outputDir);

    let flags = getCompilerFlags(options.profile, options.target);

    for (let source of sources) {
        let outputPath = getObjectPath(source, outputDir);

        if (options.verbose) {
            console.log("Compiling: " + source);
        }

        let compileResult = compileFile(source, outputPath, flags);

        if (!compileResult.success) {
            result.error = "Failed to compile " + source + ": " + compileResult.error;
            return result;
        }

        result.objects.push(outputPath);

        for (let warning of compileResult.warnings) {
            result.warnings.push(warning);
        }
    }

    if (lockfile != null) {
        let depResult = compileDependencies(lockfile, outputDir, flags, options.verbose);
        if (!depResult.success) {
            result.error = depResult.error;
            return result;
        }

        for (let obj of depResult.objects) {
            result.objects.push(obj);
        }
    }

    result.success = true;
    return result;
}

interface CompilerFlags {
    optLevel: number;
    debug: boolean;
    lto: string;
    target: string;
}

function getCompilerFlags(profile: string, target: string): CompilerFlags {
    let flags: CompilerFlags = {
        optLevel: 0,
        debug: true,
        lto: "none",
        target: target
    };

    if (profile == "release") {
        flags.optLevel = 3;
        flags.debug = false;
        flags.lto = "thin";
    } else if (profile == "dist") {
        flags.optLevel = 3;
        flags.debug = false;
        flags.lto = "fat";
    }

    return flags;
}

function discoverSources(dir: string): string[] {
    let sources: string[] = [];
    discoverSourcesRecursive(dir, sources);
    return sources;
}

function discoverSourcesRecursive(dir: string, sources: string[]): void {
    if (!fs.existsSync(dir)) {
        return;
    }

    let entries = fs.readdirSync(dir);
    for (let entry of entries) {
        let fullPath = dir + "/" + entry;

        let stats = fs.statSync(fullPath);
        if (stats && stats.isDirectory && stats.isDirectory()) {
            discoverSourcesRecursive(fullPath, sources);
        } else if (entry.indexOf(".ot") == entry.length - 3) {
            sources.push(fullPath);
        }
    }
}

function getObjectPath(source: string, outputDir: string): string {
    let name = source;

    if (name.indexOf("./src/") == 0) {
        name = name.substring(6);
    } else if (name.indexOf("src/") == 0) {
        name = name.substring(4);
    }

    name = name.split("/").join("_");

    if (name.length > 3 && name.substring(name.length - 3) == ".ot") {
        name = name.substring(0, name.length - 3) + ".o";
    }

    return outputDir + "/" + name;
}

interface SingleCompileResult {
    success: boolean;
    error: string;
    warnings: CompileWarning[];
}

function compileFile(source: string, output: string, flags: CompilerFlags): SingleCompileResult {
    let args: string[] = ["build", source, "-o", output];

    if (flags.optLevel > 0) {
        args.push("-O" + flags.optLevel);
    }

    if (flags.debug) {
        args.push("-g");
    }

    if (flags.lto != "none") {
        args.push("--lto=" + flags.lto);
    }

    if (flags.target != "native") {
        args.push("--target=" + flags.target);
    }

    let result = executeCompiler(args);

    return {
        success: result.exitCode == 0,
        error: result.stderr,
        warnings: parseWarnings(result.stdout)
    };
}

function compileDependencies(lockfile: Lockfile, outputDir: string, flags: CompilerFlags, verbose: boolean): CompileResult {
    // TODO: Implement dependency compilation
    return {
        success: true,
        error: "",
        objects: [],
        warnings: []
    };
}

interface ExecuteResult {
    exitCode: number;
    stdout: string;
    stderr: string;
}

function executeCompiler(args: string[]): ExecuteResult {
    let oitec = findOitec();
    if (oitec == "") {
        return {
            exitCode: 1,
            stdout: "",
            stderr: "Could not find oitec compiler. Make sure it's in PATH or OITEC_PATH is set."
        };
    }

    let result = process.exec(oitec, args);
    return {
        exitCode: result.exitCode,
        stdout: result.stdout,
        stderr: result.stderr
    };
}

function findOitec(): string {
    let oitecPath = process.env.get("OITEC_PATH");
    if (oitecPath != "" && oitecPath != null) {
        return oitecPath;
    }

    let locations = [
        "oitec",
        "./oitec",
        "../oite/target/debug/oite",
        "../oite/target/release/oite",
        "/usr/local/bin/oitec",
        process.env.get("HOME") + "/.oite/bin/oitec"
    ];

    for (let loc of locations) {
        let result = process.exec("which", [loc]);
        if (result.exitCode == 0) {
            return result.stdout.trim();
        }
        let testResult = process.exec(loc, ["--version"]);
        if (testResult.exitCode == 0 || testResult.stdout != "" || testResult.stderr.indexOf("not found") == -1) {
            return loc;
        }
    }

    return "";
}

function parseWarnings(output: string): CompileWarning[] {
    // TODO: Implement
    return [];
}

function createDirectory(path: string): void {
    if (!fs.existsSync(path)) {
        fs.mkdirSync(path, { recursive: true });
    }
}

export { compileSources, CompileOptions, CompileResult };
