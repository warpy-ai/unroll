import { loadManifest, Manifest } from "../config/manifest.ot";
import { discoverTests } from "../build/test_discovery.ot";

interface TestOptions {
    filter: string;
    coverage: boolean;
    verbose: boolean;
    nocapture: boolean;
    jobs: number;
}

function parseTestArgs(args: string[]): TestOptions {
    let options: TestOptions = {
        filter: "",
        coverage: false,
        verbose: false,
        nocapture: false,
        jobs: 0
    };

    for (let i = 0; i < args.length; i = i + 1) {
        let arg = args[i];

        if (arg == "--filter" || arg == "-f") {
            i = i + 1;
            if (i < args.length) {
                options.filter = args[i];
            }
        } else if (arg == "--coverage") {
            options.coverage = true;
        } else if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--nocapture") {
            options.nocapture = true;
        } else if (arg == "--jobs" || arg == "-j") {
            i = i + 1;
            if (i < args.length) {
                options.jobs = parseInt(args[i]);
            }
        } else if (arg[0] != "-") {
            options.filter = arg;
        }
    }

    return options;
}

function runTest(args: string[]): number {
    let options = parseTestArgs(args);

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        return 1;
    }

    console.log("Running tests for " + manifest.name + "...");
    console.log("");

    let tests = discoverTests("./tests", options.filter);

    if (tests.length == 0) {
        console.log("No tests found");
        return 0;
    }

    console.log("Found " + tests.length + " test(s)");
    console.log("");

    let passed = 0;
    let failed = 0;
    let skipped = 0;

    for (let test of tests) {
        let result = runSingleTest(test, options);

        if (result.status == "passed") {
            passed = passed + 1;
            if (options.verbose) {
                console.log("  PASS " + test.name);
            }
        } else if (result.status == "failed") {
            failed = failed + 1;
            console.log("  FAIL " + test.name);
            if (result.message != "") {
                console.log("       " + result.message);
            }
        } else if (result.status == "skipped") {
            skipped = skipped + 1;
            if (options.verbose) {
                console.log("  SKIP " + test.name);
            }
        }
    }

    console.log("");
    console.log("Results: " + passed + " passed, " + failed + " failed, " + skipped + " skipped");

    if (options.coverage) {
        console.log("");
        console.log("Generating coverage report...");
        generateCoverageReport();
    }

    return failed > 0 ? 1 : 0;
}

interface TestFile {
    name: string;
    path: string;
}

interface TestResult {
    status: string;  // "passed" | "failed" | "skipped"
    message: string;
    duration: number;
}

function runSingleTest(test: TestFile, options: TestOptions): TestResult {
    let oitec = findOitec();
    if (oitec == "") {
        return {
            status: "failed",
            message: "Could not find oite compiler",
            duration: 0
        };
    }

    let result = process.exec(oitec, [test.path]);

    if (result.exitCode == 0) {
        if (options.nocapture && result.stdout != "") {
            console.log(result.stdout);
        }
        return { status: "passed", message: "", duration: 0 };
    }

    let message = result.stderr != "" ? result.stderr : result.stdout;
    return { status: "failed", message: message.trim(), duration: 0 };
}

function findOitec(): string {
    let oitecPath = process.env.get("OITEC_PATH");
    if (oitecPath != "" && oitecPath != null) {
        return oitecPath;
    }

    let locations = [
        "oitec",
        "./oitec",
        "../oite/target/debug/oite",
        "../oite/target/release/oite",
        "/usr/local/bin/oitec",
        process.env.get("HOME") + "/.oite/bin/oitec"
    ];

    for (let loc of locations) {
        let testResult = process.exec(loc, ["--version"]);
        if (testResult.exitCode == 0) {
            return loc;
        }
    }

    return "";
}

function generateCoverageReport(): void {
    // TODO: Implement coverage report generation
    console.log("Coverage: not yet implemented");
}

function parseInt(s: string): number {
    let result = 0;
    for (let i = 0; i < s.length; i = i + 1) {
        let c = s[i];
        if (c >= "0" && c <= "9") {
            result = result * 10 + (c.charCodeAt(0) - 48);
        }
    }
    return result;
}

export { runTest, TestOptions };
