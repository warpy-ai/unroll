import { loadManifest, saveManifest, Manifest, Dependency } from "../config/manifest.ot";
import { resolveDependencies } from "../resolver/mod.ot";
import { writeLockfile } from "../config/lockfile.ot";

interface AddOptions {
    packages: string[];
    dev: boolean;
    optional: boolean;
    features: string[];
}

function parseAddArgs(args: string[]): AddOptions {
    let options: AddOptions = {
        packages: [],
        dev: false,
        optional: false,
        features: []
    };

    for (let i = 0; i < args.length; i = i + 1) {
        let arg = args[i];

        if (arg == "--dev" || arg == "-D") {
            options.dev = true;
        } else if (arg == "--optional") {
            options.optional = true;
        } else if (arg == "--features") {
            i = i + 1;
            if (i < args.length) {
                options.features = args[i].split(",");
            }
        } else if (arg[0] != "-") {
            options.packages.push(arg);
        }
    }

    return options;
}

function runAdd(args: string[]): number {
    let options = parseAddArgs(args);

    if (options.packages.length == 0) {
        console.error("Error: no packages specified");
        console.error("Usage: unroll add <package> [--dev] [--optional]");
        return 1;
    }

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        console.error("Run 'unroll init' to create a project");
        return 1;
    }

    for (let pkg of options.packages) {
        let parsed = parsePackageSpec(pkg);

        console.log("Adding " + parsed.name + "@" + parsed.version + "...");

        if (options.dev) {
            addDevDependency(manifest, parsed.name, parsed.version, options);
        } else {
            addDependency(manifest, parsed.name, parsed.version, options);
        }
    }

    console.log("Resolving dependencies...");
    let resolved = resolveDependencies(manifest);
    if (resolved.error != "") {
        console.error("Error resolving dependencies: " + resolved.error);
        return 1;
    }

    let result = saveManifest("./unroll.toml", manifest);
    if (!result.success) {
        console.error("Error saving manifest: " + result.error);
        return 1;
    }

    result = writeLockfile("./unroll.lock", resolved.packages);
    if (!result.success) {
        console.error("Error writing lockfile: " + result.error);
        return 1;
    }

    console.log("Added " + options.packages.length + " package(s)");
    return 0;
}

interface PackageSpec {
    name: string;
    version: string;
}

function parsePackageSpec(spec: string): PackageSpec {
    let atIndex = spec.lastIndexOf("@");

    if (atIndex == 0) {
        let secondAt = spec.indexOf("@", 1);
        if (secondAt > 0) {
            return {
                name: spec.substring(0, secondAt),
                version: spec.substring(secondAt + 1)
            };
        }
        return { name: spec, version: "*" };
    }

    if (atIndex > 0) {
        return {
            name: spec.substring(0, atIndex),
            version: spec.substring(atIndex + 1)
        };
    }

    return { name: spec, version: "*" };
}

function addDependency(manifest: Manifest, name: string, version: string, options: AddOptions): void {
    for (let i = 0; i < manifest.dependencies.length; i = i + 1) {
        if (manifest.dependencies[i].name == name) {
            manifest.dependencies[i].version = version;
            manifest.dependencies[i].optional = options.optional;
            manifest.dependencies[i].features = options.features;
            return;
        }
    }

    manifest.dependencies.push({
        name: name,
        version: version,
        optional: options.optional,
        features: options.features,
        git: "",
        branch: "",
        path: ""
    });
}

function addDevDependency(manifest: Manifest, name: string, version: string, options: AddOptions): void {
    for (let i = 0; i < manifest.devDependencies.length; i = i + 1) {
        if (manifest.devDependencies[i].name == name) {
            manifest.devDependencies[i].version = version;
            manifest.devDependencies[i].optional = options.optional;
            manifest.devDependencies[i].features = options.features;
            return;
        }
    }

    manifest.devDependencies.push({
        name: name,
        version: version,
        optional: options.optional,
        features: options.features,
        git: "",
        branch: "",
        path: ""
    });
}

interface RemoveOptions {
    packages: string[];
}

function parseRemoveArgs(args: string[]): RemoveOptions {
    let options: RemoveOptions = {
        packages: []
    };

    for (let arg of args) {
        if (arg[0] != "-") {
            options.packages.push(arg);
        }
    }

    return options;
}

function runRemove(args: string[]): number {
    let options = parseRemoveArgs(args);

    if (options.packages.length == 0) {
        console.error("Error: no packages specified");
        console.error("Usage: unroll remove <package>");
        return 1;
    }

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        return 1;
    }

    for (let pkg of options.packages) {
        console.log("Removing " + pkg + "...");
        removeDependency(manifest, pkg);
    }

    let resolved = resolveDependencies(manifest);
    saveManifest("./unroll.toml", manifest);
    writeLockfile("./unroll.lock", resolved.packages);

    console.log("Removed " + options.packages.length + " package(s)");
    return 0;
}

function removeDependency(manifest: Manifest, name: string): void {
    let newDeps: any[] = [];
    for (let dep of manifest.dependencies) {
        if (dep.name != name) {
            newDeps.push(dep);
        }
    }
    manifest.dependencies = newDeps;

    let newDevDeps: any[] = [];
    for (let dep of manifest.devDependencies) {
        if (dep.name != name) {
            newDevDeps.push(dep);
        }
    }
    manifest.devDependencies = newDevDeps;
}

interface UpdateOptions {
    packages: string[];
    all: boolean;
}

function parseUpdateArgs(args: string[]): UpdateOptions {
    let options: UpdateOptions = {
        packages: [],
        all: false
    };

    for (let arg of args) {
        if (arg == "--all") {
            options.all = true;
        } else if (arg[0] != "-") {
            options.packages.push(arg);
        }
    }

    if (options.packages.length == 0) {
        options.all = true;
    }

    return options;
}

function runUpdate(args: string[]): number {
    let options = parseUpdateArgs(args);

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        return 1;
    }

    if (options.all) {
        console.log("Updating all dependencies...");
    } else {
        console.log("Updating: " + options.packages.join(", "));
    }

    let resolved = resolveDependencies(manifest);
    if (resolved.error != "") {
        console.error("Error resolving dependencies: " + resolved.error);
        return 1;
    }

    let result = writeLockfile("./unroll.lock", resolved.packages);
    if (!result.success) {
        console.error("Error writing lockfile: " + result.error);
        return 1;
    }

    console.log("Updated dependencies");
    return 0;
}

export { runAdd, runRemove, runUpdate };
