// LSP Signature Help Handler
// Shows function parameter info while typing function calls.

import { sendResponse } from "./transport.ot";
import { DocumentStore, uriToPath } from "./documents.ot";
import { SymbolIndex, SymbolInfo, getWordAtPosition } from "./symbols.ot";

/**
 * Handle textDocument/signatureHelp request.
 * Returns signature info for the function being called at cursor position.
 */
function handleSignatureHelp(id: any, params: any, documents: DocumentStore, symbols: SymbolIndex): void {
    let uri = params.textDocument.uri;
    let line = params.position.line;
    let character = params.position.character;

    let content = documents.get(uri);
    if (content == null) {
        sendResponse(id, null);
        return;
    }

    let lines = content.split("\n");
    if (line < 0 || line >= lines.length) {
        sendResponse(id, null);
        return;
    }

    let lineText = lines[line];

    // Find the function name by scanning backwards from cursor to find the opening (
    let callInfo = findCallContext(lineText, character);
    if (callInfo == null) {
        sendResponse(id, null);
        return;
    }

    let funcName = callInfo.name;
    let activeParam = callInfo.paramIndex;

    // Look up the function in symbol index
    let signature = findSignature(funcName, content, uri, symbols);
    if (signature == null) {
        sendResponse(id, null);
        return;
    }

    // Parse parameters from the signature
    let paramLabels = parseParamLabels(signature);

    let parameters: any[] = [];
    for (let p of paramLabels) {
        parameters.push({ label: p });
    }

    let result: any = {
        signatures: [{
            label: signature,
            parameters: parameters
        }],
        activeSignature: 0,
        activeParameter: activeParam
    };

    sendResponse(id, result);
}

/**
 * Find the function call context at a given position.
 * Returns { name, paramIndex } or null.
 */
function findCallContext(lineText: string, character: number): any {
    // Walk backwards from cursor to find the opening (
    let depth = 0;
    let commaCount = 0;
    let i = character - 1;

    while (i >= 0) {
        let c = lineText[i];

        // Skip string literals
        if (c == "\"" || c == "'") {
            let quote = c;
            i = i - 1;
            while (i >= 0 && lineText[i] != quote) {
                if (i > 0 && lineText[i - 1] == "\\") {
                    i = i - 1;
                }
                i = i - 1;
            }
            i = i - 1;
            continue;
        }

        if (c == ")") {
            depth = depth + 1;
        } else if (c == "(") {
            if (depth == 0) {
                // Found the opening paren — extract function name before it
                let nameEnd = i;
                let nameStart = nameEnd - 1;
                while (nameStart >= 0) {
                    let nc = lineText[nameStart];
                    if ((nc >= "a" && nc <= "z") || (nc >= "A" && nc <= "Z") ||
                        (nc >= "0" && nc <= "9") || nc == "_" || nc == "$") {
                        nameStart = nameStart - 1;
                    } else {
                        break;
                    }
                }
                nameStart = nameStart + 1;

                if (nameStart < nameEnd) {
                    let name = lineText.substring(nameStart, nameEnd);
                    return { name: name, paramIndex: commaCount };
                }
                return null;
            }
            depth = depth - 1;
        } else if (c == "," && depth == 0) {
            commaCount = commaCount + 1;
        }

        i = i - 1;
    }

    return null;
}

/**
 * Find the signature string for a function name.
 * Searches symbol index and falls back to scanning the document.
 */
function findSignature(funcName: string, content: string, uri: string, symbols: SymbolIndex): string {
    // Search symbol index
    let matches = symbols.findByName(funcName);
    for (let sym of matches) {
        if (sym.kind == "function" && sym.detail != "") {
            return sym.detail;
        }
    }

    // Fallback: scan current document
    let lines = content.split("\n");
    for (let i = 0; i < lines.length; i = i + 1) {
        let trimmed = lines[i].trim();
        let rest = trimmed;
        if (rest.startsWith("export ")) {
            rest = rest.substring(7).trim();
        }
        if (rest.startsWith("async ")) {
            rest = rest.substring(6).trim();
        }

        if (rest.startsWith("function " + funcName + "(") ||
            rest.startsWith("function " + funcName + "<")) {
            // Extract the signature up to the opening brace
            let sig = rest;
            let braceIdx = sig.indexOf("{");
            if (braceIdx > 0) {
                sig = sig.substring(0, braceIdx).trim();
            }
            return sig;
        }
    }

    // Try to find it via imports
    let importSig = findSignatureViaImport(funcName, content, uri);
    if (importSig != null) {
        return importSig;
    }

    return null;
}

/**
 * Try to find a function signature by following imports.
 */
function findSignatureViaImport(funcName: string, content: string, currentUri: string): string {
    let lines = content.split("\n");

    for (let i = 0; i < lines.length; i = i + 1) {
        let trimmed = lines[i].trim();
        if (!trimmed.startsWith("import ")) {
            continue;
        }

        // Check if this import includes the function name
        let braceStart = trimmed.indexOf("{");
        let braceEnd = trimmed.indexOf("}");
        if (braceStart < 0 || braceEnd < 0) {
            continue;
        }

        let namesStr = trimmed.substring(braceStart + 1, braceEnd);
        let names = namesStr.split(",");
        let found = false;
        for (let n of names) {
            if (n.trim() == funcName) {
                found = true;
            }
        }
        if (!found) {
            continue;
        }

        // Extract and resolve the import path
        let fromIdx = trimmed.indexOf(" from ");
        if (fromIdx < 0) continue;

        let afterFrom = trimmed.substring(fromIdx + 6).trim();
        let importPath = "";
        if (afterFrom.startsWith("\"")) {
            let rest = afterFrom.substring(1);
            let endQuote = rest.indexOf("\"");
            if (endQuote > 0) {
                importPath = rest.substring(0, endQuote);
            }
        }
        if (importPath == "") continue;

        // Resolve relative to current file
        let currentPath = uriToPath(currentUri);
        let lastSlash = currentPath.lastIndexOf("/");
        if (lastSlash < 0) continue;
        let dir = currentPath.substring(0, lastSlash);

        let resolved = "";
        if (importPath.startsWith("./")) {
            resolved = dir + "/" + importPath.substring(2);
        } else if (importPath.startsWith("../")) {
            let parts = importPath;
            let base = dir;
            while (parts.startsWith("../")) {
                parts = parts.substring(3);
                let parentSlash = base.lastIndexOf("/");
                if (parentSlash >= 0) {
                    base = base.substring(0, parentSlash);
                }
            }
            resolved = base + "/" + parts;
        }
        if (resolved == "" || !fs.existsSync(resolved)) continue;

        // Read and scan the target file
        let fileContent = fs.readFileSync(resolved);
        if (fileContent == null) continue;

        let fileLines = fileContent.split("\n");
        for (let j = 0; j < fileLines.length; j = j + 1) {
            let fTrimmed = fileLines[j].trim();
            let fRest = fTrimmed;
            if (fRest.startsWith("export ")) {
                fRest = fRest.substring(7).trim();
            }
            if (fRest.startsWith("async ")) {
                fRest = fRest.substring(6).trim();
            }

            if (fRest.startsWith("function " + funcName + "(") ||
                fRest.startsWith("function " + funcName + "<")) {
                let sig = fRest;
                let braceIdx2 = sig.indexOf("{");
                if (braceIdx2 > 0) {
                    sig = sig.substring(0, braceIdx2).trim();
                }
                return sig;
            }
        }
    }

    return null;
}

/**
 * Parse parameter labels from a function signature.
 * E.g., "function foo(a: string, b: number): void" → ["a: string", "b: number"]
 */
function parseParamLabels(signature: string): string[] {
    let params: string[] = [];

    let parenStart = signature.indexOf("(");
    if (parenStart < 0) return params;

    // Find matching closing paren
    let depth = 0;
    let parenEnd = -1;
    for (let i = parenStart; i < signature.length; i = i + 1) {
        let c = signature[i];
        if (c == "(") {
            depth = depth + 1;
        } else if (c == ")") {
            depth = depth - 1;
            if (depth == 0) {
                parenEnd = i;
                break;
            }
        }
    }

    if (parenEnd < 0) return params;

    let paramsStr = signature.substring(parenStart + 1, parenEnd).trim();
    if (paramsStr == "") return params;

    // Split by commas, respecting nested generics < >
    let current = "";
    let angleDepth = 0;

    for (let i = 0; i < paramsStr.length; i = i + 1) {
        let c = paramsStr[i];
        if (c == "<") {
            angleDepth = angleDepth + 1;
            current = current + c;
        } else if (c == ">") {
            angleDepth = angleDepth - 1;
            current = current + c;
        } else if (c == "," && angleDepth == 0) {
            let trimmed = current.trim();
            if (trimmed != "") {
                params.push(trimmed);
            }
            current = "";
        } else {
            current = current + c;
        }
    }

    let lastParam = current.trim();
    if (lastParam != "") {
        params.push(lastParam);
    }

    return params;
}

export { handleSignatureHelp };
