import { loadManifest } from "../config/manifest.ot";

interface LintOptions {
    fix: boolean;
    verbose: boolean;
    files: string[];
    rules: string[];
}

function parseLintArgs(args: string[]): LintOptions {
    let options: LintOptions = {
        fix: false,
        verbose: false,
        files: [],
        rules: []
    };

    for (let i = 0; i < args.length; i = i + 1) {
        let arg = args[i];

        if (arg == "--fix") {
            options.fix = true;
        } else if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--rule") {
            i = i + 1;
            if (i < args.length) {
                options.rules.push(args[i]);
            }
        } else if (arg[0] != "-") {
            options.files.push(arg);
        }
    }

    return options;
}

function runLint(args: string[]): number {
    let options = parseLintArgs(args);

    let files = options.files;
    if (files.length == 0) {
        files = discoverSourceFiles("./src");
    }

    if (files.length == 0) {
        console.log("No files to lint");
        return 0;
    }

    console.log("Linting " + files.length + " file(s)...");
    console.log("");

    let totalWarnings = 0;
    let totalErrors = 0;
    let fixedCount = 0;

    for (let file of files) {
        let diagnostics = lintFile(file, options.rules);

        for (let diag of diagnostics) {
            if (diag.severity == "error") {
                totalErrors = totalErrors + 1;
            } else {
                totalWarnings = totalWarnings + 1;
            }

            if (options.fix && diag.fix != null) {
                let fixed = applyFix(file, diag.fix);
                if (fixed) {
                    fixedCount = fixedCount + 1;
                    continue;
                }
            }

            printDiagnostic(file, diag);
        }
    }

    console.log("");
    if (totalErrors > 0 || totalWarnings > 0) {
        console.log("Found " + totalErrors + " error(s), " + totalWarnings + " warning(s)");
        if (fixedCount > 0) {
            console.log("Fixed " + fixedCount + " issue(s)");
        }
        return totalErrors > 0 ? 1 : 0;
    }

    console.log("No issues found");
    return 0;
}

interface Diagnostic {
    severity: string;  // "error" | "warning" | "info"
    message: string;
    line: number;
    column: number;
    rule: string;
    fix: Fix | null;
}

interface Fix {
    range: Range;
    replacement: string;
}

interface Range {
    startLine: number;
    startColumn: number;
    endLine: number;
    endColumn: number;
}

function lintFile(path: string, rules: string[]): Diagnostic[] {
    let content = readFile(path);
    if (content == null) {
        return [{
            severity: "error",
            message: "Could not read file",
            line: 0,
            column: 0,
            rule: "io",
            fix: null
        }];
    }

    let diagnostics: Diagnostic[] = [];

    diagnostics = diagnostics.concat(checkUnusedVariables(content));
    diagnostics = diagnostics.concat(checkConsoleStatements(content));
    diagnostics = diagnostics.concat(checkTodoComments(content));
    diagnostics = diagnostics.concat(checkLineLength(content));

    return diagnostics;
}

function checkUnusedVariables(content: string): Diagnostic[] {
    // TODO: Implement unused variable detection
    return [];
}

function checkConsoleStatements(content: string): Diagnostic[] {
    // TODO: Implement console.log detection
    return [];
}

function checkTodoComments(content: string): Diagnostic[] {
    // TODO: Implement TODO comment detection
    return [];
}

function checkLineLength(content: string): Diagnostic[] {
    let diagnostics: Diagnostic[] = [];
    let lines = content.split("\n");
    let maxLength = 100;

    for (let i = 0; i < lines.length; i = i + 1) {
        if (lines[i].length > maxLength) {
            diagnostics.push({
                severity: "warning",
                message: "Line exceeds " + maxLength + " characters",
                line: i + 1,
                column: maxLength + 1,
                rule: "max-line-length",
                fix: null
            });
        }
    }

    return diagnostics;
}

function applyFix(file: string, fix: Fix): boolean {
    // TODO: Implement fix application
    return false;
}

function printDiagnostic(file: string, diag: Diagnostic): void {
    let severityStr = diag.severity == "error" ? "error" : "warning";
    console.log(file + ":" + diag.line + ":" + diag.column + " " + severityStr + ": " + diag.message + " [" + diag.rule + "]");
}

function discoverSourceFiles(dir: string): string[] {
    let files: string[] = [];
    discoverSourceFilesRecursive(dir, files);
    return files;
}

function discoverSourceFilesRecursive(dir: string, files: string[]): void {
    if (!fs.existsSync(dir)) {
        return;
    }

    let entries = fs.readdirSync(dir);
    for (let entry of entries) {
        let fullPath = dir + "/" + entry;

        let stats = fs.statSync(fullPath);
        if (stats && stats.isDirectory && stats.isDirectory()) {
            discoverSourceFilesRecursive(fullPath, files);
        } else if (entry.indexOf(".ot") == entry.length - 3) {
            files.push(fullPath);
        }
    }
}

function readFile(path: string): string | null {
    try {
        return fs.readFileSync(path);
    } catch (e) {
        return null;
    }
}

export { runLint, LintOptions };
