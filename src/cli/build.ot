import { loadManifest, Manifest } from "../config/manifest.ot";
import { loadLockfile, Lockfile } from "../config/lockfile.ot";
import { compileSources } from "../build/compiler.ot";
import { linkBinary } from "../build/linker.ot";

interface BuildOptions {
    release: boolean;
    dist: boolean;
    target: string;
    jobs: number;
    verbose: boolean;
    noStd: boolean;
}

function parseBuildArgs(args: string[]): BuildOptions {
    let options: BuildOptions = {
        release: false,
        dist: false,
        target: "native",
        jobs: 0,
        verbose: false,
        noStd: false
    };

    for (let i = 0; i < args.length; i = i + 1) {
        let arg = args[i];

        if (arg == "--release" || arg == "-r") {
            options.release = true;
        } else if (arg == "--dist") {
            options.dist = true;
            options.release = true;
        } else if (arg == "--target") {
            i = i + 1;
            if (i < args.length) {
                options.target = args[i];
            }
        } else if (arg == "--jobs" || arg == "-j") {
            i = i + 1;
            if (i < args.length) {
                options.jobs = parseInt(args[i]);
            }
        } else if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--no-std") {
            options.noStd = true;
        }
    }

    return options;
}

function runBuild(args: string[]): number {
    let options = parseBuildArgs(args);

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        return 1;
    }

    let lockfile = loadLockfile("./unroll.lock");

    let profile = "dev";
    if (options.dist) {
        profile = "dist";
    } else if (options.release) {
        profile = "release";
    }

    console.log("Building " + manifest.name + " (" + profile + ")...");

    let compileResult = compileSources(manifest, lockfile, {
        profile: profile,
        target: options.target,
        jobs: options.jobs,
        verbose: options.verbose
    });

    if (!compileResult.success) {
        console.error("Compilation failed: " + compileResult.error);
        return 1;
    }

    let linkResult = linkBinary(manifest, compileResult.objects, {
        profile: profile,
        target: options.target
    });

    if (!linkResult.success) {
        console.error("Linking failed: " + linkResult.error);
        return 1;
    }

    let outputPath = "./target/" + profile + "/" + manifest.name;
    console.log("Built: " + outputPath);

    return 0;
}

interface RunOptions {
    release: boolean;
    args: string[];
}

function parseRunArgs(args: string[]): RunOptions {
    let options: RunOptions = {
        release: false,
        args: []
    };

    let foundSeparator = false;
    for (let i = 0; i < args.length; i = i + 1) {
        let arg = args[i];

        if (arg == "--") {
            foundSeparator = true;
        } else if (foundSeparator) {
            options.args.push(arg);
        } else if (arg == "--release" || arg == "-r") {
            options.release = true;
        }
    }

    return options;
}

function runRun(args: string[]): number {
    let options = parseRunArgs(args);

    let buildArgs: string[] = [];
    if (options.release) {
        buildArgs.push("--release");
    }

    let buildResult = runBuild(buildArgs);
    if (buildResult != 0) {
        return buildResult;
    }

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        return 1;
    }

    let profile = options.release ? "release" : "dev";
    let binaryPath = "./target/" + profile + "/" + manifest.name;

    console.log("");
    console.log("Running " + binaryPath + "...");
    console.log("");

    let exitCode = executeProcess(binaryPath, options.args);
    return exitCode;
}

function executeProcess(path: string, args: string[]): number {
    let result = process.exec(path, args);

    if (result.stdout != "") {
        console.log(result.stdout);
    }
    if (result.stderr != "") {
        console.error(result.stderr);
    }

    return result.exitCode;
}

interface WatchOptions {
    release: boolean;
    run: boolean;
}

function parseWatchArgs(args: string[]): WatchOptions {
    let options: WatchOptions = {
        release: false,
        run: false
    };

    for (let i = 0; i < args.length; i = i + 1) {
        let arg = args[i];

        if (arg == "--release" || arg == "-r") {
            options.release = true;
        } else if (arg == "--run") {
            options.run = true;
        }
    }

    return options;
}

function runWatch(args: string[]): number {
    let options = parseWatchArgs(args);

    console.log("Watching for changes...");
    console.log("Press Ctrl+C to stop");
    console.log("");

    let buildArgs: string[] = [];
    if (options.release) {
        buildArgs.push("--release");
    }
    runBuild(buildArgs);

    watchFiles("./src", () => {
        console.log("");
        console.log("Change detected, rebuilding...");
        runBuild(buildArgs);

        if (options.run) {
            let manifest = loadManifest("./unroll.toml");
            if (manifest != null) {
                let profile = options.release ? "release" : "dev";
                let binaryPath = "./target/" + profile + "/" + manifest.name;
                executeProcess(binaryPath, []);
            }
        }
    });

    return 0;
}

function watchFiles(path: string, callback: () => void): void {
    // TODO: Implement using fs events
}

function runClean(args: string[]): number {
    console.log("Cleaning build artifacts...");

    let result = removeDirectory("./target");
    if (!result.success) {
        console.error("Error cleaning: " + result.error);
        return 1;
    }

    console.log("Cleaned");
    return 0;
}

interface Result {
    success: boolean;
    error: string;
}

function removeDirectory(path: string): Result {
    if (!fs.existsSync(path)) {
        return { success: true, error: "" };
    }

    let result = process.exec("rm", ["-rf", path]);
    if (result.exitCode != 0) {
        return { success: false, error: result.stderr };
    }

    return { success: true, error: "" };
}

function parseInt(s: string): number {
    let result = 0;
    for (let i = 0; i < s.length; i = i + 1) {
        let c = s[i];
        if (c >= "0" && c <= "9") {
            result = result * 10 + (c.charCodeAt(0) - 48);
        }
    }
    return result;
}

export { runBuild, runRun, runWatch, runClean, BuildOptions };
