// LSP Hover Handler
// Shows information when hovering over symbols, types, and keywords.

import { sendResponse } from "./transport.ot";
import { DocumentStore } from "./documents.ot";
import { SymbolIndex, getWordAtPosition } from "./symbols.ot";

/**
 * Handle textDocument/hover request.
 */
function handleHover(id: any, params: any, documents: DocumentStore, symbols: SymbolIndex): void {
    let uri = params.textDocument.uri;
    let line = params.position.line;
    let character = params.position.character;

    let content = documents.get(uri);
    if (content == null) {
        sendResponse(id, null);
        return;
    }

    let word = getWordAtPosition(content, line, character);
    if (word == "") {
        sendResponse(id, null);
        return;
    }

    // 1. Look up in symbol index
    let symbolMatches = symbols.findByName(word);
    if (symbolMatches.length > 0) {
        sendResponse(id, buildSymbolHover(symbolMatches));
        return;
    }

    // 2. Look up in built-in types
    let typeHover = getBuiltinTypeHover(word);
    if (typeHover != null) {
        sendResponse(id, typeHover);
        return;
    }

    // 3. Look up in keywords
    let keywordHover = getKeywordHover(word);
    if (keywordHover != null) {
        sendResponse(id, keywordHover);
        return;
    }

    sendResponse(id, null);
}

function buildSymbolHover(symbolMatches: any[]): any {
    let parts: string[] = [];

    for (let sym of symbolMatches) {
        let kindLabel = sym.kind;

        switch (kindLabel) {
            case "function":
                kindLabel = "function";
                break;
            case "class":
                kindLabel = "class";
                break;
            case "interface":
                kindLabel = "interface";
                break;
            case "variable":
                kindLabel = "variable";
                break;
            case "type":
                kindLabel = "type";
                break;
            default:
                kindLabel = sym.kind; // Fallback to original kind if not recognized
        }

        parts.push("**" + kindLabel + "** `" + sym.name + "`");
        if (sym.detail != "") {
            parts.push("```typescript\n" + sym.detail + "\n```");
        }
    }

    return {
        contents: {
            kind: "markdown",
            value: parts.join("\n\n")
        }
    };
}

function getBuiltinTypeHover(word: string): any {
    let description = "";

    switch (word) {
        case "string":
            description = "**type** `string`\n\nString primitive type. Represents a sequence of UTF-16 characters.";
            break;
        case "number":
            description = "**type** `number`\n\nNumeric primitive type. 64-bit IEEE 754 floating point.";
            break;
        case "boolean":
            description = "**type** `boolean`\n\nBoolean primitive type. Either `true` or `false`.";
            break;
        case "void":
            description = "**type** `void`\n\nVoid type. Indicates a function returns no value.";
            break;
        case "any":
            description = "**type** `any`\n\nAny type. Disables type checking for this value.";
            break;
        case "null":
            description = "**type** `null`\n\nNull type. Represents an intentionally empty value.";
            break;
        case "undefined":
            description = "**type** `undefined`\n\nUndefined type. Variable declared but not assigned.";
            break;
        case "object":
            description = "**type** `object`\n\nObject type. A non-primitive value with properties.";
            break;
        case "Array":
            description = "**type** `Array<T>`\n\nGeneric array type. Ordered collection of elements.";
            break;
        case "Map":
            description = "**type** `Map<K, V>`\n\nKey-value collection with unique keys.";
            break;
        case "Set":
            description = "**type** `Set<T>`\n\nCollection of unique values.";
            break;
        case "Promise":
            description = "**type** `Promise<T>`\n\nRepresents an asynchronous operation's result.";
            break;
    }

    if (description == "") {
        return null;
    }

    return {
        contents: {
            kind: "markdown",
            value: description
        }
    };
}

function getKeywordHover(word: string): any {
    let description = "";


    switch (word) {
        case "let":
            description = "**keyword** `let`\n\nDeclares a block-scoped variable. In Oite, `let` bindings use move semantics by default.";
            break;
        case "const":
            description = "**keyword** `const`\n\nDeclares a read-only constant. Value cannot be reassigned after initialization.";
            break;
        case "function":
            description = "**keyword** `function`\n\nDeclares a named function.";
            break;
        case "class":
            description = "**keyword** `class`\n\nDeclares a class with constructor, methods, and properties.";
            break;
        case "interface":
            description = "**keyword** `interface`\n\nDeclares a type interface. Describes the shape of an object.";
            break;
        case "import":
            description = "**keyword** `import`\n\nImports bindings from another module.\n\n```typescript\nimport { name } from \"./module\";\n```";
            break;
        case "export":
            description = "**keyword** `export`\n\nExports bindings for use by other modules.\n\n```typescript\nexport function name() { }\n```";
            break;
        case "return":
            description = "**keyword** `return`\n\nReturns a value from a function.";
            break;
        case "if":
            description = "**keyword** `if`\n\nConditional execution.";
            break;
        case "else":
            description = "**keyword** `else`\n\nAlternate branch of an `if` statement.";
            break;
        case "for":
            description = "**keyword** `for`\n\nLoop construct. Supports `for..of` and C-style `for(;;)`.";
            break;
        case "while":
            description = "**keyword** `while`\n\nLoop that executes while condition is true.";
            break;
        case "async":
            description = "**keyword** `async`\n\nMarks a function as asynchronous (returns a Promise).";
            break;
        case "await":
            description = "**keyword** `await`\n\nWaits for a Promise to resolve.";
            break;
        case "new":
            description = "**keyword** `new`\n\nCreates a new instance of a class.";
            break;
        case "typeof":
            description = "**keyword** `typeof`\n\nReturns the type of a value as a string.";
            break;
        case "borrow":
            description = "**keyword** `borrow` (Oite)\n\nBorrow a reference to a value without taking ownership.";
            break;
        case "move":
            description = "**keyword** `move` (Oite)\n\nExplicitly move ownership of a value.";
            break;
        case "mut":
            description = "**keyword** `mut` (Oite)\n\nMutable borrow modifier. `&mut` allows modifying borrowed data.";
            break;
    }

    if (description == "") {
        return null;
    }

    return {
        contents: {
            kind: "markdown",
            value: description
        }
    };
}

export { handleHover };
