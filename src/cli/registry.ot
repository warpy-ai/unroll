import { loadManifest } from "../config/manifest.ot";
import { getRegistryConfig, RegistryConfig, saveCredentials } from "../registry/config.ot";
import {
    searchPackages,
    getPackageInfo,
    getPackageVersion,
    validateToken,
    SearchResponse,
    SearchResult,
    PackageInfo,
    PackageVersion,
    UserInfo,
    ApiResult,
    parseJson
} from "../registry/client.ot";

interface SearchOptions {
    query: string;
    limit: number;
    page: number;
}

function parseSearchArgs(args: string[]): SearchOptions {
    let options: SearchOptions = {
        query: "",
        limit: 20,
        page: 1
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--limit" || arg == "-l") {
            i = i + 1;
            if (i < args.length) {
                options.limit = parseInt(args[i]);
            }
        } else if (arg == "--page" || arg == "-p") {
            i = i + 1;
            if (i < args.length) {
                options.page = parseInt(args[i]);
            }
        } else if (arg[0] != "-") {
            options.query = arg;
        }

        i = i + 1;
    }

    return options;
}

function runSearch(args: string[]): number {
    let options = parseSearchArgs(args);

    if (options.query == "") {
        console.error("Error: search query required");
        console.error("Usage: unroll search <query> [--limit N] [--page N]");
        return 1;
    }

    console.log("Searching for '" + options.query + "'...");
    console.log("");

    let result = searchPackages(options.query, options.limit, options.page);

    if (result.error != "") {
        console.error("Error: " + result.error);
        return 1;
    }

    if (result.data == null) {
        console.log("No packages found");
        return 0;
    }

    let data = result.data as SearchResponse;

    if (data.rolls == null || data.rolls.length == 0) {
        console.log("No packages found matching '" + options.query + "'");
        return 0;
    }

    let i = 0;
    while (i < data.rolls.length) {
        let pkg = data.rolls[i];
        console.log(pkg.name + " (" + pkg.max_version + ")");
        if (pkg.description != null && pkg.description != "") {
            console.log("    " + pkg.description);
        }
        if (pkg.downloads != null && pkg.downloads > 0) {
            console.log("    Downloads: " + pkg.downloads);
        }
        i = i + 1;
    }

    if (data.meta != null) {
        console.log("");
        console.log("Page " + data.meta.page + " of " + Math.ceil(data.meta.total / data.meta.per_page));
        console.log("Total: " + data.meta.total + " packages");
    }

    return 0;
}

interface InfoOptions {
    package: string;
    version: string;
    versions: boolean;
}

function parseInfoArgs(args: string[]): InfoOptions {
    let options: InfoOptions = {
        package: "",
        version: "",
        versions: false
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--versions" || arg == "-v") {
            options.versions = true;
        } else if (arg == "--version") {
            i = i + 1;
            if (i < args.length) {
                options.version = args[i];
            }
        } else if (arg[0] != "-") {
            let atIndex = arg.indexOf("@");
            if (atIndex > 0) {
                options.package = arg.substring(0, atIndex);
                options.version = arg.substring(atIndex + 1);
            } else {
                options.package = arg;
            }
        }

        i = i + 1;
    }

    return options;
}

function runInfo(args: string[]): number {
    let options = parseInfoArgs(args);

    if (options.package == "") {
        console.error("Error: package name required");
        console.error("Usage: unroll info <package>[@version] [--versions]");
        return 1;
    }

    console.log("Fetching package info for '" + options.package + "'...");
    console.log("");

    let result = getPackageInfo(options.package);

    if (result.error != "") {
        console.error("Error: " + result.error);
        return 1;
    }

    if (result.data == null) {
        console.error("Error: Package not found");
        return 1;
    }

    let info = result.data as PackageInfo;

    console.log(info.name + "@" + info.max_version);
    console.log("");

    if (info.description != null && info.description != "") {
        console.log(info.description);
        console.log("");
    }

    if (info.homepage != null && info.homepage != "") {
        console.log("Homepage:      " + info.homepage);
    }
    if (info.repository != null && info.repository != "") {
        console.log("Repository:    " + info.repository);
    }
    if (info.documentation != null && info.documentation != "") {
        console.log("Documentation: " + info.documentation);
    }
    console.log("");

    if (info.created_at != null && info.created_at != "") {
        console.log("Created:  " + info.created_at);
    }
    if (info.updated_at != null && info.updated_at != "") {
        console.log("Updated:  " + info.updated_at);
    }

    if (info.owners != null && info.owners.length > 0) {
        console.log("");
        console.log("Owners:");
        let i = 0;
        while (i < info.owners.length) {
            console.log("  - " + info.owners[i].username);
            i = i + 1;
        }
    }

    if (options.versions && info.versions != null && info.versions.length > 0) {
        console.log("");
        console.log("Versions (" + info.versions.length + "):");
        let i = 0;
        while (i < info.versions.length) {
            console.log("  - " + info.versions[i]);
            i = i + 1;
        }
    }

    if (options.version != "") {
        console.log("");
        console.log("Version " + options.version + " details:");

        let versionResult = getPackageVersion(options.package, options.version);
        if (versionResult.error != "") {
            console.error("  Error: " + versionResult.error);
        } else if (versionResult.data != null) {
            let ver = versionResult.data as PackageVersion;
            console.log("  Checksum: " + ver.checksum);
            console.log("  Download: " + ver.download_url);
            if (ver.yanked) {
                console.log("  Status:   YANKED");
            }
            if (ver.dependencies != null && ver.dependencies.length > 0) {
                console.log("  Dependencies:");
                let j = 0;
                while (j < ver.dependencies.length) {
                    let dep = ver.dependencies[j];
                    let depStr = "    - " + dep.name + " " + dep.req;
                    if (dep.optional) {
                        depStr = depStr + " (optional)";
                    }
                    console.log(depStr);
                    j = j + 1;
                }
            }
        }
    }

    return 0;
}

interface PublishOptions {
    dryRun: boolean;
}

function parsePublishArgs(args: string[]): PublishOptions {
    let options: PublishOptions = {
        dryRun: false
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];
        if (arg == "--dry-run" || arg == "-n") {
            options.dryRun = true;
        }
        i = i + 1;
    }

    return options;
}

function runPublish(args: string[]): number {
    let options = parsePublishArgs(args);

    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        return 1;
    }

    let config = getRegistryConfig();

    if (config.token == "") {
        console.error("Error: not logged in");
        console.error("Run 'unroll login' first");
        return 1;
    }

    if (manifest.name.indexOf("@") != 0 || manifest.name.indexOf("/") == -1) {
        console.error("Error: package name must be @scope/name format");
        return 1;
    }

    console.log("Packaging " + manifest.name + "@" + manifest.version + "...");

    let tarball = createTarball(".");
    if (tarball.error != "") {
        console.error("Error creating package: " + tarball.error);
        return 1;
    }

    console.log("  Created: " + tarball.data);

    if (options.dryRun) {
        console.log("");
        console.log("Dry run - not uploading to registry");
        console.log("Tarball location: " + tarball.data);
        return 0;
    }

    console.log("Uploading to " + config.url + "...");

    let uploadResult = uploadTarball(tarball.data, config.url, config.token);
    if (uploadResult.error != "") {
        console.error("Error publishing: " + uploadResult.error);
        return 1;
    }

    process.exec("rm", ["-rf", tarball.data.substring(0, tarball.data.lastIndexOf("/"))]);

    console.log("");
    console.log("Published " + manifest.name + "@" + manifest.version);
    return 0;
}

interface UploadResult {
    success: boolean;
    error: string;
}

function uploadTarball(tarballPath: string, registryUrl: string, token: string): UploadResult {
    let url = registryUrl + "/crates/new";

    let curlResult = process.exec("curl", [
        "-s",
        "-X", "POST",
        "-H", "Authorization: Bearer " + token,
        "-F", "tarball=@" + tarballPath,
        url
    ]);

    if (curlResult.exitCode != 0) {
        return { success: false, error: "Upload failed: " + curlResult.stderr };
    }

    let response = parseJson(curlResult.stdout);
    if (response == null) {
        return { success: false, error: "Invalid response from registry: " + curlResult.stdout };
    }

    if (response.success) {
        return { success: true, error: "" };
    }

    if (response.errors && response.errors.length > 0) {
        return { success: false, error: response.errors[0].detail };
    }
    if (response.error) {
        return { success: false, error: response.error };
    }

    return { success: false, error: "Unknown error: " + curlResult.stdout };
}

interface TarballResult {
    data: string;
    error: string;
}

function createTarball(dir: string): TarballResult {
    let manifest = loadManifest(dir + "/unroll.toml");
    if (manifest == null) {
        return { data: "", error: "Could not load unroll.toml" };
    }

    if (manifest.name.indexOf("@") != 0) {
        return { data: "", error: "Package name must start with @ (e.g., @scope/name)" };
    }
    if (manifest.name.indexOf("/") == -1) {
        return { data: "", error: "Package name must be @scope/name format" };
    }

    let uniqueId = generateUniqueId();
    let tempDir = "/tmp/unroll-publish-" + uniqueId;
    let pkgDir = tempDir + "/" + manifest.name.replace("@", "").replace("/", "-") + "-" + manifest.version;

    let mkdirResult = process.exec("mkdir", ["-p", pkgDir + "/src"]);
    if (mkdirResult.exitCode != 0) {
        return { data: "", error: "Failed to create temp directory: " + mkdirResult.stderr };
    }

    let rollToml = createRollToml(manifest);
    fs.writeFileSync(pkgDir + "/roll.toml", rollToml);

    let copyResult = process.exec("cp", ["-r", dir + "/src/.", pkgDir + "/src/"]);
    if (copyResult.exitCode != 0) {
        let srcExists = fs.existsSync(dir + "/src");
        if (!srcExists) {
            copyResult = process.exec("sh", ["-c", "cp " + dir + "/*.ot " + pkgDir + "/ 2>/dev/null || true"]);
        }
    }

    let tarballPath = tempDir + "/" + manifest.name.replace("@", "").replace("/", "-") + "-" + manifest.version + ".crate";
    let tarResult = process.exec("tar", ["-czf", tarballPath, "-C", tempDir, manifest.name.replace("@", "").replace("/", "-") + "-" + manifest.version]);
    if (tarResult.exitCode != 0) {
        return { data: "", error: "Failed to create tarball: " + tarResult.stderr };
    }

    if (!fs.existsSync(tarballPath)) {
        return { data: "", error: "Tarball was not created" };
    }

    return { data: tarballPath, error: "" };
}

function createRollToml(manifest: any): string {
    let toml = "[roll]\n";
    toml = toml + "name = \"" + manifest.name + "\"\n";
    toml = toml + "version = \"" + manifest.version + "\"\n";

    if (manifest.description && manifest.description != "") {
        toml = toml + "description = \"" + manifest.description + "\"\n";
    }
    if (manifest.license && manifest.license != "") {
        toml = toml + "license = \"" + manifest.license + "\"\n";
    }
    if (manifest.repository && manifest.repository != "") {
        toml = toml + "repository = \"" + manifest.repository + "\"\n";
    }

    if (manifest.dependencies && manifest.dependencies.length > 0) {
        toml = toml + "\n[dependencies]\n";
        let i = 0;
        while (i < manifest.dependencies.length) {
            let dep = manifest.dependencies[i];
            toml = toml + "\"" + dep.name + "\" = \"" + dep.version + "\"\n";
            i = i + 1;
        }
    }

    return toml;
}

interface YankOptions {
    package: string;
    version: string;
    undo: boolean;
}

function parseYankArgs(args: string[]): YankOptions {
    let options: YankOptions = {
        package: "",
        version: "",
        undo: false
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--undo") {
            options.undo = true;
        } else if (arg == "--version" || arg == "-v") {
            i = i + 1;
            if (i < args.length) {
                options.version = args[i];
            }
        } else if (arg[0] != "-") {
            let atIndex = arg.lastIndexOf("@");
            if (atIndex > 0 && arg.indexOf("/") < atIndex) {
                options.package = arg.substring(0, atIndex);
                options.version = arg.substring(atIndex + 1);
            } else {
                options.package = arg;
            }
        }

        i = i + 1;
    }

    return options;
}

function runYank(args: string[]): number {
    let options = parseYankArgs(args);

    if (options.package == "") {
        console.error("Error: package name required");
        console.error("Usage: unroll yank <package>@<version> [--undo]");
        return 1;
    }

    if (options.version == "") {
        console.error("Error: version required");
        console.error("Usage: unroll yank <package>@<version> [--undo]");
        return 1;
    }

    let config = getRegistryConfig();

    if (config.token == "") {
        console.error("Error: not logged in");
        console.error("Run 'unroll login' first");
        return 1;
    }

    let action = options.undo ? "Unyanking" : "Yanking";
    console.log(action + " " + options.package + "@" + options.version + "...");

    let url = config.url + "/crates/" + encodeURIComponent(options.package) + "/" + options.version + "/yank";
    let method = options.undo ? "DELETE" : "PUT";

    let curlResult = process.exec("curl", [
        "-s",
        "-X", method,
        "-H", "Authorization: Bearer " + config.token,
        "-H", "Content-Type: application/json",
        url
    ]);

    if (curlResult.exitCode != 0) {
        console.error("Error: request failed: " + curlResult.stderr);
        return 1;
    }

    let response = parseJson(curlResult.stdout);
    if (response == null) {
        if (curlResult.stdout == "" || curlResult.stdout == "{}") {
            let successAction = options.undo ? "Unyanked" : "Yanked";
            console.log(successAction + " " + options.package + "@" + options.version);
            return 0;
        }
        console.error("Error: invalid response from registry: " + curlResult.stdout);
        return 1;
    }

    if (response.success || response.ok) {
        let successAction = options.undo ? "Unyanked" : "Yanked";
        console.log(successAction + " " + options.package + "@" + options.version);
        return 0;
    }

    if (response.errors && response.errors.length > 0) {
        console.error("Error: " + response.errors[0].detail);
        return 1;
    }
    if (response.error) {
        console.error("Error: " + response.error);
        return 1;
    }

    console.error("Error: unknown error: " + curlResult.stdout);
    return 1;
}

function encodeURIComponent(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let c = s[i];
        if (c == "@") {
            result = result + "%40";
        } else if (c == "/") {
            result = result + "%2F";
        } else if (c == " ") {
            result = result + "%20";
        } else {
            result = result + c;
        }
        i = i + 1;
    }
    return result;
}

function runLogin(args: string[]): number {
    let config = getRegistryConfig();

    if (config.token != "") {
        let checkResult = validateToken(config.token);
        if (checkResult.error == "" && checkResult.data != null) {
            let user = checkResult.data as UserInfo;
            console.log("Already logged in as " + user.username);
            console.log("Run 'unroll logout' first to log in as a different user");
            return 0;
        }
    }

    console.log("Logging in to " + config.url + "...");
    console.log("");
    console.log("Visit this URL to authenticate:");
    console.log(config.url.replace("/api/v1", "") + "/cli/login");
    console.log("");
    console.log("Then paste your token below:");

    let token = readLine();

    if (token == "" || token == null) {
        console.error("Error: no token provided");
        return 1;
    }

    token = token.trim();

    let validResult = validateToken(token);
    if (validResult.error != "") {
        console.error("Error: " + validResult.error);
        return 1;
    }

    if (validResult.data == null) {
        console.error("Error: invalid token");
        return 1;
    }

    let user = validResult.data as UserInfo;

    let saved = saveCredentials(config.url, token);
    if (!saved) {
        console.error("Error: could not save credentials");
        return 1;
    }

    console.log("");
    console.log("Logged in as " + user.username);
    return 0;
}

function runLogout(args: string[]): number {
    let config = getRegistryConfig();

    if (config.token == "") {
        console.log("Not logged in");
        return 0;
    }

    let saved = saveCredentials(config.url, "");
    if (!saved) {
        console.error("Error: could not clear credentials");
        return 1;
    }

    console.log("Logged out");
    return 0;
}

function readLine(): string {
    // TODO: Implement in oite's stdlib
    return "";
}

function parseInt(s: string): number {
    let result = 0;
    let i = 0;
    while (i < s.length) {
        let c = s[i];
        if (c >= "0" && c <= "9") {
            result = result * 10 + (c.charCodeAt(0) - "0".charCodeAt(0));
        }
        i = i + 1;
    }
    return result;
}

function generateUniqueId(): string {
    let dateResult = process.exec("date", ["+%s%N"]);
    if (dateResult.exitCode == 0 && dateResult.stdout != "") {
        return dateResult.stdout.trim();
    }

    let fallbackResult = process.exec("date", ["+%s"]);
    if (fallbackResult.exitCode == 0 && fallbackResult.stdout != "") {
        let randomResult = process.exec("sh", ["-c", "echo $RANDOM"]);
        let random = randomResult.stdout.trim();
        return fallbackResult.stdout.trim() + "-" + random;
    }

    return "pkg-" + Math.floor(Math.random() * 1000000);
}

export { runSearch, runInfo, runPublish, runYank, runLogin, runLogout };
