// Dependency resolver - resolve package versions and build dependency graph

import { Manifest, Dependency } from "../config/manifest.ot";
import { LockedPackage } from "../config/lockfile.ot";
import { fetchPackageVersions, PackageVersion } from "../registry/client.ot";

interface ResolveResult {
    packages: LockedPackage[];
    error: string;
}

interface DependencyNode {
    name: string;
    version: string;
    dependencies: DependencyNode[];
}

// The implicit standard library dependency
const STD_DEPENDENCY: Dependency = {
    name: "@rolls/std",
    version: "0.1",
    optional: false,
    features: [],
    git: "",
    branch: "",
    path: ""
};

function resolveDependencies(manifest: Manifest, noStd: boolean = false): ResolveResult {
    let resolved: LockedPackage[] = [];
    let visited: string[] = [];

    // Inject @rolls/std implicitly unless disabled
    // This is the prelude that provides standard library functions automatically
    if (!manifest.noStd && !noStd) {
        let stdResult = resolveSingle(STD_DEPENDENCY, visited, resolved);
        if (stdResult.error != "") {
            return { packages: [], error: stdResult.error };
        }
    }

    // Resolve all direct dependencies
    let i = 0;
    while (i < manifest.dependencies.length) {
        let dep = manifest.dependencies[i];
        let result = resolveSingle(dep, visited, resolved);
        if (result.error != "") {
            return { packages: [], error: result.error };
        }
        i = i + 1;
    }

    // Resolve dev dependencies
    i = 0;
    while (i < manifest.devDependencies.length) {
        let dep = manifest.devDependencies[i];
        let result = resolveSingle(dep, visited, resolved);
        if (result.error != "") {
            return { packages: [], error: result.error };
        }
        i = i + 1;
    }

    // Sort for deterministic lockfile
    resolved = sortPackages(resolved);

    return { packages: resolved, error: "" };
}

interface SingleResult {
    error: string;
}

function resolveSingle(dep: Dependency, visited: string[], resolved: LockedPackage[]): SingleResult {
    // Check if already resolved
    if (isVisited(dep.name, visited)) {
        return { error: "" };
    }

    // Mark as visited
    visited.push(dep.name);

    // Fetch available versions
    let versions = fetchPackageVersions(dep.name);
    if (versions.error != "") {
        return { error: "Failed to fetch versions for " + dep.name + ": " + versions.error };
    }

    // Find best matching version
    let selected = selectVersion(dep.version, versions.versions);
    if (selected == null) {
        return { error: "No matching version found for " + dep.name + "@" + dep.version };
    }

    // Resolve transitive dependencies
    let i = 0;
    while (i < selected.dependencies.length) {
        let transDep: Dependency = {
            name: selected.dependencies[i].name,
            version: selected.dependencies[i].version,
            optional: false,
            features: [],
            git: "",
            branch: "",
            path: ""
        };
        let result = resolveSingle(transDep, visited, resolved);
        if (result.error != "") {
            return result;
        }
        i = i + 1;
    }

    // Add to resolved list
    let depNames: string[] = [];
    i = 0;
    while (i < selected.dependencies.length) {
        depNames.push(selected.dependencies[i].name + " " + selected.dependencies[i].version);
        i = i + 1;
    }

    resolved.push({
        name: dep.name,
        version: selected.version,
        source: "registry+https://registry.oite.org",
        checksum: selected.checksum,
        dependencies: depNames
    });

    return { error: "" };
}

function isVisited(name: string, visited: string[]): boolean {
    let i = 0;
    while (i < visited.length) {
        if (visited[i] == name) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

function selectVersion(requirement: string, versions: PackageVersion[]): PackageVersion | null {
    // Simple version matching
    // TODO: Implement full semver parsing and matching

    if (requirement == "*" || requirement == "") {
        // Return latest version
        if (versions.length > 0) {
            return versions[0];
        }
        return null;
    }

    // Exact match
    if (requirement[0] == "=") {
        let exact = requirement.substring(1);
        let i = 0;
        while (i < versions.length) {
            if (versions[i].version == exact) {
                return versions[i];
            }
            i = i + 1;
        }
        return null;
    }

    // Caret range (default) - ^0.1.0 means >=0.1.0, <0.2.0
    let i = 0;
    while (i < versions.length) {
        if (matchesCaretRange(requirement, versions[i].version)) {
            return versions[i];
        }
        i = i + 1;
    }

    return null;
}

function matchesCaretRange(requirement: string, version: string): boolean {
    // Parse requirement (e.g., "0.1" or "0.1.0")
    let reqParts = requirement.split(".");
    let verParts = version.split(".");

    // Must match major version
    if (reqParts.length > 0 && verParts.length > 0) {
        if (reqParts[0] != verParts[0]) {
            return false;
        }
    }

    // For 0.x versions, must also match minor
    if (reqParts[0] == "0" && reqParts.length > 1 && verParts.length > 1) {
        if (reqParts[1] != verParts[1]) {
            return false;
        }
    }

    return true;
}

function sortPackages(packages: LockedPackage[]): LockedPackage[] {
    // Simple bubble sort by name
    let i = 0;
    while (i < packages.length) {
        let j = i + 1;
        while (j < packages.length) {
            if (packages[j].name < packages[i].name) {
                let temp = packages[i];
                packages[i] = packages[j];
                packages[j] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return packages;
}

export { resolveDependencies, ResolveResult };
