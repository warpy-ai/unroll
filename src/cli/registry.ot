// Registry commands: search, info, publish, login

import { loadManifest } from "../config/manifest.ot";
import { getRegistryConfig, RegistryConfig, saveCredentials } from "../registry/config.ot";
import {
    searchPackages,
    getPackageInfo,
    getPackageVersion,
    validateToken,
    publishPackage,
    SearchResponse,
    SearchResult,
    PackageInfo,
    PackageVersion,
    UserInfo,
    ApiResult
} from "../registry/client.ot";

// ============================================================================
// unroll search
// ============================================================================

interface SearchOptions {
    query: string;
    limit: number;
    page: number;
}

function parseSearchArgs(args: string[]): SearchOptions {
    let options: SearchOptions = {
        query: "",
        limit: 20,
        page: 1
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--limit" || arg == "-l") {
            i = i + 1;
            if (i < args.length) {
                options.limit = parseInt(args[i]);
            }
        } else if (arg == "--page" || arg == "-p") {
            i = i + 1;
            if (i < args.length) {
                options.page = parseInt(args[i]);
            }
        } else if (arg[0] != "-") {
            options.query = arg;
        }

        i = i + 1;
    }

    return options;
}

function runSearch(args: string[]): number {
    let options = parseSearchArgs(args);

    if (options.query == "") {
        console.error("Error: search query required");
        console.error("Usage: unroll search <query> [--limit N] [--page N]");
        return 1;
    }

    console.log("Searching for '" + options.query + "'...");
    console.log("");

    let result = searchPackages(options.query, options.limit, options.page);

    if (result.error != "") {
        console.error("Error: " + result.error);
        return 1;
    }

    if (result.data == null) {
        console.log("No packages found");
        return 0;
    }

    let data = result.data as SearchResponse;

    if (data.rolls == null || data.rolls.length == 0) {
        console.log("No packages found matching '" + options.query + "'");
        return 0;
    }

    // Display results
    let i = 0;
    while (i < data.rolls.length) {
        let pkg = data.rolls[i];
        console.log(pkg.name + " (" + pkg.max_version + ")");
        if (pkg.description != null && pkg.description != "") {
            console.log("    " + pkg.description);
        }
        if (pkg.downloads != null && pkg.downloads > 0) {
            console.log("    Downloads: " + pkg.downloads);
        }
        i = i + 1;
    }

    // Display pagination info
    if (data.meta != null) {
        console.log("");
        console.log("Page " + data.meta.page + " of " + Math.ceil(data.meta.total / data.meta.per_page));
        console.log("Total: " + data.meta.total + " packages");
    }

    return 0;
}

// ============================================================================
// unroll info
// ============================================================================

interface InfoOptions {
    package: string;
    version: string;
    versions: boolean;
}

function parseInfoArgs(args: string[]): InfoOptions {
    let options: InfoOptions = {
        package: "",
        version: "",
        versions: false
    };

    let i = 0;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--versions" || arg == "-v") {
            options.versions = true;
        } else if (arg == "--version") {
            i = i + 1;
            if (i < args.length) {
                options.version = args[i];
            }
        } else if (arg[0] != "-") {
            // Check if package@version format
            let atIndex = arg.indexOf("@");
            if (atIndex > 0) {
                options.package = arg.substring(0, atIndex);
                options.version = arg.substring(atIndex + 1);
            } else {
                options.package = arg;
            }
        }

        i = i + 1;
    }

    return options;
}

function runInfo(args: string[]): number {
    let options = parseInfoArgs(args);

    if (options.package == "") {
        console.error("Error: package name required");
        console.error("Usage: unroll info <package>[@version] [--versions]");
        return 1;
    }

    console.log("Fetching package info for '" + options.package + "'...");
    console.log("");

    let result = getPackageInfo(options.package);

    if (result.error != "") {
        console.error("Error: " + result.error);
        return 1;
    }

    if (result.data == null) {
        console.error("Error: Package not found");
        return 1;
    }

    let info = result.data as PackageInfo;

    // Header
    console.log(info.name + "@" + info.max_version);
    console.log("");

    // Description
    if (info.description != null && info.description != "") {
        console.log(info.description);
        console.log("");
    }

    // Links
    if (info.homepage != null && info.homepage != "") {
        console.log("Homepage:      " + info.homepage);
    }
    if (info.repository != null && info.repository != "") {
        console.log("Repository:    " + info.repository);
    }
    if (info.documentation != null && info.documentation != "") {
        console.log("Documentation: " + info.documentation);
    }
    console.log("");

    // Dates
    if (info.created_at != null && info.created_at != "") {
        console.log("Created:  " + info.created_at);
    }
    if (info.updated_at != null && info.updated_at != "") {
        console.log("Updated:  " + info.updated_at);
    }

    // Owners
    if (info.owners != null && info.owners.length > 0) {
        console.log("");
        console.log("Owners:");
        let i = 0;
        while (i < info.owners.length) {
            console.log("  - " + info.owners[i].username);
            i = i + 1;
        }
    }

    // Versions
    if (options.versions && info.versions != null && info.versions.length > 0) {
        console.log("");
        console.log("Versions (" + info.versions.length + "):");
        let i = 0;
        while (i < info.versions.length) {
            console.log("  - " + info.versions[i]);
            i = i + 1;
        }
    }

    // If specific version requested, show its details
    if (options.version != "") {
        console.log("");
        console.log("Version " + options.version + " details:");

        let versionResult = getPackageVersion(options.package, options.version);
        if (versionResult.error != "") {
            console.error("  Error: " + versionResult.error);
        } else if (versionResult.data != null) {
            let ver = versionResult.data as PackageVersion;
            console.log("  Checksum: " + ver.checksum);
            console.log("  Download: " + ver.download_url);
            if (ver.yanked) {
                console.log("  Status:   YANKED");
            }
            if (ver.dependencies != null && ver.dependencies.length > 0) {
                console.log("  Dependencies:");
                let j = 0;
                while (j < ver.dependencies.length) {
                    let dep = ver.dependencies[j];
                    let depStr = "    - " + dep.name + " " + dep.req;
                    if (dep.optional) {
                        depStr = depStr + " (optional)";
                    }
                    console.log(depStr);
                    j = j + 1;
                }
            }
        }
    }

    return 0;
}

// ============================================================================
// unroll publish
// ============================================================================

function runPublish(args: string[]): number {
    // Load manifest
    let manifest = loadManifest("./unroll.toml");
    if (manifest == null) {
        console.error("Error: could not find unroll.toml");
        return 1;
    }

    let config = getRegistryConfig();

    // Check authentication
    if (config.token == "") {
        console.error("Error: not logged in");
        console.error("Run 'unroll login' first");
        return 1;
    }

    console.log("Publishing " + manifest.name + "@" + manifest.version + "...");

    // Package the project
    let tarball = createTarball(".");
    if (tarball.error != "") {
        console.error("Error creating package: " + tarball.error);
        return 1;
    }

    // Upload to registry
    let result = publishPackage(tarball.data, config.token);
    if (result.error != "") {
        console.error("Error publishing: " + result.error);
        return 1;
    }

    console.log("Published " + manifest.name + "@" + manifest.version);
    return 0;
}

interface TarballResult {
    data: string;
    error: string;
}

function createTarball(dir: string): TarballResult {
    // TODO: Implement tarball creation
    // This will need to:
    // 1. Read unroll.toml
    // 2. Collect all source files
    // 3. Create .crate tarball format
    return { data: "", error: "Tarball creation not yet implemented" };
}

// ============================================================================
// unroll login
// ============================================================================

function runLogin(args: string[]): number {
    let config = getRegistryConfig();

    // Check if already logged in
    if (config.token != "") {
        let checkResult = validateToken(config.token);
        if (checkResult.error == "" && checkResult.data != null) {
            let user = checkResult.data as UserInfo;
            console.log("Already logged in as " + user.username);
            console.log("Run 'unroll logout' first to log in as a different user");
            return 0;
        }
    }

    console.log("Logging in to " + config.url + "...");
    console.log("");
    console.log("Visit this URL to authenticate:");
    console.log(config.url.replace("/api/v1", "") + "/cli/login");
    console.log("");
    console.log("Then paste your token below:");

    // Read token from stdin
    let token = readLine();

    if (token == "" || token == null) {
        console.error("Error: no token provided");
        return 1;
    }

    // Trim whitespace
    token = token.trim();

    // Validate token
    let validResult = validateToken(token);
    if (validResult.error != "") {
        console.error("Error: " + validResult.error);
        return 1;
    }

    if (validResult.data == null) {
        console.error("Error: invalid token");
        return 1;
    }

    let user = validResult.data as UserInfo;

    // Save token
    let saved = saveCredentials(config.url, token);
    if (!saved) {
        console.error("Error: could not save credentials");
        return 1;
    }

    console.log("");
    console.log("Logged in as " + user.username);
    return 0;
}

// ============================================================================
// unroll logout
// ============================================================================

function runLogout(args: string[]): number {
    let config = getRegistryConfig();

    if (config.token == "") {
        console.log("Not logged in");
        return 0;
    }

    // Clear credentials
    let saved = saveCredentials(config.url, "");
    if (!saved) {
        console.error("Error: could not clear credentials");
        return 1;
    }

    console.log("Logged out");
    return 0;
}

// ============================================================================
// Helpers
// ============================================================================

function readLine(): string {
    // Use oite's built-in stdin reading
    // TODO: This needs to be implemented in oite's stdlib
    return "";
}

function parseInt(s: string): number {
    let result = 0;
    let i = 0;
    while (i < s.length) {
        let c = s[i];
        if (c >= "0" && c <= "9") {
            result = result * 10 + (c.charCodeAt(0) - "0".charCodeAt(0));
        }
        i = i + 1;
    }
    return result;
}

export { runSearch, runInfo, runPublish, runLogin, runLogout };
